=head1 NAME

holo - minimal configuration management

=head1 SYNOPSIS

holo B<apply> [I<-f|--force>] [I<file> ...]

holo B<scan> [I<-s|--short>]

holo B<--help|--version>

=head1 DESCRIPTION

Holo adds a few sprinkles on top of package management to make it suitable for
basic configuration management tasks. Its prime directive is to have all
configuration statically declared and defined within packages, which can be
installed to add new configuration, or uninstalled to remove configuration from
a system.

Package management already offers 99% of the needed tools: Metapackages (usually
called "holograms" or "holodecks" in Holo) can pull in other packages as
dependencies, thus installing the software required for a certain task, and
contain their own files to configure the software installed.

Holo adds facilties to work around shortcomings (from the configuration
management perspective) of the package management:

=over 4

=item *

A configuration repository resolves file conflicts when multiple packages
(holograms or system packages) work on the same configuration file.

=item *

Future releases will add management for other entities, such as system users
and groups.

=back

=head1 OPERATIONS

=over 4

=item B<apply> [I<-f|--force>] [I<file> ...]

Apply configuration from Holo's repository using the application algorithm
described in this manpage. Also, when repository files (or target configuration
files) are deleted, but there are still backups of the original configuration
files around, these are scrubbed (either deleted or restored, depending on the
situation found). You can always run C<holo scan> beforehand to check what will
be done.

By default, all available configuration files are applied. If files are listed
as arguments, apply configuration only to these target files.

By default, Holo will refuse to write to configuration files that have been
changed by the user or by other programs. Apply B<--force> to overwrite such
changes.

=item B<scan> [I<-s|--short>]

Scan the configuration repository, and print a report of what the application
algorithm will do with its contents. This operation does not write anything and
thus generally does not need to be performed with elevated privileges.

With B<--short>, only lists the names of target configuration files.

=back

=head1 OPTIONS

=over 4

=item B<--help>

Print out usage information.

=item B<--version>

Print out Holo's version string.

=back

=for Comment
################################################################################
# NOTE: The parts below are synchronized with the website-index.pod. When      #
#       editing either, make sure to apply the same changes to the other.      #
################################################################################

=head1 The configuration repository

Package management does not allow multiple packages to install a file in the
same location. So when an application package installs a default configuration
file, a hologram cannot directly overwrite this configuration file.

    $ pacman -Qo /etc/nginx/nginx.conf
    /etc/nginx/nginx.conf is owned by nginx 1.8.0-1

Instead, Holo offers a configuration repository at F</usr/share/holo/repo> where the
hologram can put its configuration file.

    $ pacman -Qo /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf
    /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf is owned by hologram-webserver 1.0.0-1

The C<holo apply> command is then used to install the hologram's configuration
file in the right place. Most package management tools allow packages to carry
post-install hooks for this purpose.

    $ sudo holo apply
    [holo] Working on /etc/nginx/nginx.conf
    [holo]   store at /var/lib/holo/backup/etc/nginx/nginx.conf
    [holo]      apply /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf

Entries in the configuration repository follow a fixed naming scheme:

    /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf
      ^         ^            ^
      |         |            |
      |         |            +-- path to target
      |         |
      |         +-- disambiguator
      |
      +-- repository path

The disambiguator is always required, and allows multiple repository files to
operate on the same target (sorted alphabetically by their disambiguator). The
pattern of putting a number at the start of the disambiguator is not required,
but useful to control the ordering of repo files.

=head1 Application strategies

When the repository file is a plain file or a symlink, the default strategy
("apply") is to copy this file to the target location. Symlink targets are
copied verbatim, so relative symlinks should be relative to the target
directory.

When the repository file is an executable file or a symlink to an executable
file carrying the extra C<.holoscript> extension, the script is executed and the
contents of the original file are piped through it to obtain the resulting
configuration file. This strategy is called "passthru" in the output of C<holo
apply> and C<holo scan>.

For example, the following setup installs the default configuration for Pacman,
but enables the "Color" option which is commented out in the default
configuration.

    $ holo scan
    ...
    /etc/pacman.conf
        store at /var/lib/holo/backup/etc/pacman.conf
        passthru /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
    ...
    $ cat /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
    #!/bin/sh
    sed 's/^#\s*Color$/Color/'

The advantage of holoscripts over plain configuration files is that when the
default configuration is updated, you get the updates as well during the next
C<holo apply>.

    $ sudo pacman -Syu
    ...
    (3/8) upgrading pacman
    warning: /etc/pacman.conf installed as /etc/pacman.conf.pacnew
    ... 

In this example, the system update includes a new default configuration, which
is placed next to the currently used configuration. Holo will recognize this and
use the new default configuration:

    $ sudo holo apply
    ...
    [holo] Working on /etc/pacman.conf
    [holo]     update /etc/pacman.conf.pacnew -&gt; /var/lib/holo/backup/etc/pacman.conf
    [holo]   passthru /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
    ... 

Another advantage is that multiple holoscripts can be chained. Multiple
holograms can thus modify the same default configuration, or further specialize
a base configuration provided by a base hologram:

    $ holo scan
    ...
    /etc/pacman.conf
        store at /var/lib/holo/backup/etc/pacman.conf
           apply /usr/share/holo/repo/00-base/etc/pacman.conf
        passthru /usr/share/holo/repo/10-add-catalyst-repo/etc/pacman.conf.holoscript
        passthru /usr/share/holo/repo/20-enable-color/etc/pacman.conf.holoscript
    ... 

As seen in this example, the disambiguator is used to determine the application
order when multiple repository files work on the same target. There is no
restriction on how repository files are ordered. When somewhere in the
application chain, a plain file is found, the effects of all previous
application steps are discarded and overwritten by that config file.

=head1 The backup directory

Before Holo overwrites the default configuration supplied by the application
package, it always takes a copy which is placed below F</var/lib/holo/backup>. This
typically happens only once. The first C<holo apply> after installing a new
hologram might look like this:

    $ sudo holo apply
    [holo] Working on /etc/nginx/nginx.conf
    [holo]   store at /var/lib/holo/backup/etc/nginx/nginx.conf
    [holo]      apply /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf

But when C<holo apply> is run again, it recognizes that the backup is already
up-to-date:

    $ sudo holo apply
    [holo] Working on /etc/nginx/nginx.conf
    [holo]      apply /usr/share/holo/repo/20-webserver/etc/nginx/nginx.conf

Besides allowing the user to inspect the default configuration, this backup
serves two purposes: First, it is used as a base for applying holoscripts.
Second, the owner, group, permissions and timestamps of the target configuration
are always copied from this backup, and thus match the corresponding metadata of
the default configuration.

=head1 Management of UNIX user accounts and groups

Holograms can install JSON files into F</usr/share/holo> that describe UNIX
user accounts and groups that shall be created during C<holo apply> runs.
For example:

    $ cat /usr/share/holo/01-example.json
    {
        "groups": [
            { "name": "foo" },
            { "name": "bar", "system": true }
        ],
        "users": [
            { "name": "foo", "group": "foo" },
            { "name": "qux", "home": "/var/lib/qux", "system": true }
        ]
    }
    $ sudo holo apply
    [holo] Working on group:bar
    [holo]     create group with type: system
    [holo] Working on group:foo
    [holo]     create group
    [holo] Working on user:foo
    [holo]     create user with group: foo
    [holo] Working on user:qux
    [holo]     create user with type: system, home directory: /var/lib/qux

Behind the scenes, this uses the C<shadow> tools (C<useradd>, C<usermod>,
C<groupadd> and C<groupmod>), so the above is exactly equivalent to

    $ sudo groupadd --system bar
    $ sudo groupadd foo
    $ sudo useradd --gid foo foo
    $ sudo useradd --system --home-dir /var/lib/qux qux

In the JSON definition files, the following attributes are accepted for groups:

* `name` (string; the group name)
* `system` (bool; if true, gives `--system` to `groupadd`)
* `gid` (integer; given to `groupadd` as `--gid`)

And the following attributes are accepted for users:

* `name` (string; the user name)
* `comment` (string; given to `useradd` as `--comment`)
* `system` (bool; if true, gives `--system` to `useradd`)
* `uid` (integer; given to `useradd` as `--uid`)
* `group` (string; given to `useradd` as `--gid`)
* `groups` (array of strings; given to `useradd` as `--groups`)
* `home` (string; given to `useradd` as `--home-dir`)
* `shell` (string; given to `useradd` as `--shell`)

In either case, `name` is the only required attribute.

In contrast to files, where Holo operates very confidently (and only refuses
operation when target files were modified manually), users and groups are
treated more carefully. First, whenever an existing user account or group does
not exactly match the definition in the JSON file, Holo will not touch it
unless instructed to apply `--force`:

    $ sudo holo apply user:qux
    [holo] Working on user:qux
    [holo]        has home directory: /var/qux, expected /var/lib/qux (use --force to overwrite)
    $ sudo holo apply --force user:qux
    [holo] Working on user:qux
    [holo]        fix home directory: /var/qux, expected /var/lib/qux

Second, when a hologram is deleted, Holo will never automatically clean up
users or groups (as it does for configuration files), since there might still
be files belonging to the users/groups in question. Recommended best practice
is to have the hologram print a message in its post-remove routine instructing
the administrator to clean up lingering users/groups manually.

=head1 AUTHOR

Stefan Majewsky

Further documentation is available at the project homepage: http://holotools.org

Please report any issues and feature requests at Github: http://github.com/majewsky/holo/issues

=cut
